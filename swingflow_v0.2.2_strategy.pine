// This Pine Scriptâ„¢ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© SwingFlow v0.2.2 Strategy
// If you find this useful, buy me a coffee: https://www.buymeacoffee.com/savowood
// Keep up-to-date on the latest version at https://github.com/savowood/SwingFlow
//@version=6
strategy("SwingFlow v0.2.2 Strategy", shorttitle="SF v0.2.2 BT", overlay=true, 
         initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=100,
         commission_type=strategy.commission.percent, commission_value=0.1,
         slippage=2, max_boxes_count=500, max_lines_count=500, max_labels_count=500)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CHANGELOG v0.2.2
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Strategy version includes all v0.2.2 indicator improvements plus:
// - Full backtesting capabilities
// - Performance statistics tracking
// - Date range filtering for optimization
// - Enhanced entry mode testing (Pullback vs Breakout)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BACKTESTING SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

enableBacktest = input.bool(true, "Enable Backtesting", group="Backtesting")
initialCapital = input.float(10000, "Initial Capital ($)", minval=100, group="Backtesting")
riskPerTrade = input.float(100, "Risk Per Trade (% of equity)", minval=1, maxval=100, step=1, group="Backtesting")
useTP1Exit = input.bool(true, "Use TP1 (50% exit)", group="Backtesting")
useTP2Exit = input.bool(true, "Use TP2 (full exit)", group="Backtesting")
showStats = input.bool(true, "Show Performance Stats", group="Backtesting")

// Backtesting Date Range
useDateFilter = input.bool(false, "Use Date Filter", group="Backtesting Date Range")
startDate = input.time(timestamp("01 Jan 2023 00:00"), "Start Date", group="Backtesting Date Range")
endDate = input.time(timestamp("31 Dec 2025 23:59"), "End Date", group="Backtesting Date Range")

// Date filter
inDateRange = true
if useDateFilter
    inDateRange := time >= startDate and time <= endDate

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SETTINGS PANEL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// VWAP Settings
vwapStdev1 = input.float(2.0, "VWAP StdDev 1", minval=0.5, maxval=5.0, step=0.5, group="VWAP Settings")
vwapStdev2 = input.float(3.0, "VWAP StdDev 2", minval=0.5, maxval=5.0, step=0.5, group="VWAP Settings")

// Trading Style Selection
tradingStyle = input.string("Intraday", "Trading Style", options=["Scalping", "Intraday", "Swing", "Medium Term", "Long Term"], group="Trading Style")

// Trade Direction
showLongs = input.bool(true, "Show Long Signals", group="Trade Direction")
showShorts = input.bool(true, "Show Short Signals", group="Trade Direction")

// Entry Filters - NEW ENHANCED ENTRY MODE
entryMode = input.string("Both", "Entry Mode", options=["Pullback Only", "Breakout Only", "Both"], 
                         tooltip="Pullback: Price returns to VWAP from extremes\nBreakout: Price crosses VWAP with momentum\nBoth: Catches all valid setups", 
                         group="Entry Filters")
vwapProximity = input.float(2.0, "VWAP Proximity (%)", minval=0.5, maxval=10.0, step=0.5,
                            tooltip="How close to VWAP price needs to be for pullback signals (% of price)", 
                            group="Entry Filters")
macdHistogramExpansion = input.bool(true, "MACD Histogram Expansion", group="Entry Filters")
volumeConfirmation = input.bool(true, "Volume Confirmation", group="Entry Filters")
trendFilter = input.bool(false, "Trend Filter (50 EMA)", group="Entry Filters")
fvgFilter = input.bool(false, "FVG Support/Resistance", group="Entry Filters")
histogramJumpDetection = input.bool(true, "Histogram Jump Detection", group="Entry Filters")
histogramJumpThreshold = input.float(15.0, "Histogram Jump Threshold (%)", minval=5.0, maxval=100.0, step=5.0, group="Entry Filters")

// Risk Management
rrRatio = input.float(3.0, "Risk:Reward Ratio", minval=1.0, maxval=10.0, step=0.5, group="Risk Management")
stopLossMethod = input.string("Percentage", "Stop Loss Method", options=["Percentage", "Swing", "ATR", "VWAP"], group="Risk Management")
stopLossPct = input.float(2.0, "Stop Loss %", minval=0.1, maxval=20.0, step=0.1, group="Risk Management")
atrMultiplier = input.float(1.5, "ATR Multiplier (for ATR method)", minval=0.5, maxval=5.0, step=0.1, group="Risk Management")

// Visual Options
showEntryArrows = input.bool(true, "Show Entry Arrows", group="Visual Options")
showStopLoss = input.bool(true, "Show Stop Loss Lines", group="Visual Options")
showTakeProfit = input.bool(true, "Show Take Profit Lines", group="Visual Options")
showFVG = input.bool(true, "Show Fair Value Gaps", group="Visual Options")
showVWAPBands = input.bool(true, "Show VWAP Bands", group="Visual Options")
show50EMA = input.bool(false, "Show 50 EMA", group="Visual Options")
showRRLabel = input.bool(true, "Label Risk:Reward on Chart", group="Visual Options")
showEntryType = input.bool(true, "Show Entry Type (Pullback/Breakout)", group="Visual Options")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ADAPTIVE PARAMETERS BASED ON TRADING STYLE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var int macdFast = 12
var int macdSlow = 26
var int macdSignal = 9
var int volumeLength = 20
var float defaultStopPct = 2.0

if tradingStyle == "Scalping"
    macdFast := 8
    macdSlow := 17
    macdSignal := 9
    volumeLength := 10
    defaultStopPct := 0.75
else if tradingStyle == "Intraday"
    macdFast := 12
    macdSlow := 26
    macdSignal := 9
    volumeLength := 20
    defaultStopPct := 2.0
else if tradingStyle == "Swing"
    macdFast := 12
    macdSlow := 26
    macdSignal := 9
    volumeLength := 30
    defaultStopPct := 3.0
else if tradingStyle == "Medium Term"
    macdFast := 19
    macdSlow := 39
    macdSignal := 9
    volumeLength := 50
    defaultStopPct := 6.0
else if tradingStyle == "Long Term"
    macdFast := 12
    macdSlow := 26
    macdSignal := 9
    volumeLength := 20
    defaultStopPct := 12.0

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INDICATOR CALCULATIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// VWAP and Bands
vwapValue = ta.vwap(close)
vwapStdDevCalc = ta.stdev(close, 20)
vwapUpper1 = vwapValue + (vwapStdDevCalc * vwapStdev1)
vwapLower1 = vwapValue - (vwapStdDevCalc * vwapStdev1)
vwapUpper2 = vwapValue + (vwapStdDevCalc * vwapStdev2)
vwapLower2 = vwapValue - (vwapStdDevCalc * vwapStdev2)

// MACD
[macdLine, signalLine, histogram] = ta.macd(close, macdFast, macdSlow, macdSignal)

// Volume
volumeMA = ta.sma(volume, volumeLength)
volumeSurge = volume > volumeMA

// 50 EMA (Trend Filter)
ema50 = ta.ema(close, 50)

// ATR (for stop loss)
atr = ta.atr(14)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MACD HISTOGRAM ANALYSIS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Detect histogram expansion
histogramExpanding = histogram > histogram[1] and histogram > 0
histogramContractingDown = histogram < histogram[1] and histogram < 0

// Detect histogram "jump" - was declining, then suddenly surges back
histogramDeclining = histogram[1] < histogram[2] and histogram[2] < histogram[3]
histogramJump = histogramDeclining and (histogram > histogram[1] * (1 + histogramJumpThreshold / 100)) and histogram > 0

histogramDecliningBearish = histogram[1] > histogram[2] and histogram[2] > histogram[3]
histogramJumpBearish = histogramDecliningBearish and (histogram < histogram[1] * (1 - histogramJumpThreshold / 100)) and histogram < 0

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FAIR VALUE GAPS (FVG) DETECTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Bullish FVG: Gap between bar[2] high and current bar low
bullishFVG = low > high[2] and (low - high[2]) / close > 0.005
bullishFVGtop = low
bullishFVGbottom = high[2]

// Bearish FVG: Gap between bar[2] low and current bar high
bearishFVG = high < low[2] and (low[2] - high) / close > 0.005
bearishFVGtop = low[2]
bearishFVGbottom = high

// Track FVG boxes and remove when price fills them
var box[] bullishFVGboxes = array.new<box>()
var box[] bearishFVGboxes = array.new<box>()

// Create new FVG boxes
if bullishFVG and showFVG
    fvgBox = box.new(bar_index - 2, bullishFVGtop, bar_index + 20, bullishFVGbottom, 
                      border_color=color.new(color.green, 80), 
                      bgcolor=color.new(color.green, 90),
                      border_width=1)
    array.push(bullishFVGboxes, fvgBox)

if bearishFVG and showFVG
    fvgBox = box.new(bar_index - 2, bearishFVGtop, bar_index + 20, bearishFVGbottom, 
                      border_color=color.new(color.red, 80), 
                      bgcolor=color.new(color.red, 90),
                      border_width=1)
    array.push(bearishFVGboxes, fvgBox)

// Remove filled FVG boxes
if array.size(bullishFVGboxes) > 0
    for i = array.size(bullishFVGboxes) - 1 to 0
        fvgBox = array.get(bullishFVGboxes, i)
        fvgBottom = box.get_bottom(fvgBox)
        if low <= fvgBottom
            box.delete(fvgBox)
            array.remove(bullishFVGboxes, i)

if array.size(bearishFVGboxes) > 0
    for i = array.size(bearishFVGboxes) - 1 to 0
        fvgBox = array.get(bearishFVGboxes, i)
        fvgTop = box.get_top(fvgBox)
        if high >= fvgTop
            box.delete(fvgBox)
            array.remove(bearishFVGboxes, i)

// Extend unfilled boxes
if array.size(bullishFVGboxes) > 0
    for i = 0 to array.size(bullishFVGboxes) - 1
        box.set_right(array.get(bullishFVGboxes, i), bar_index + 5)

if array.size(bearishFVGboxes) > 0
    for i = 0 to array.size(bearishFVGboxes) - 1
        box.set_right(array.get(bearishFVGboxes, i), bar_index + 5)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ENHANCED ENTRY SIGNAL LOGIC - v0.2.2
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// VWAP Cross Detection
vwapCrossUp = ta.crossover(close, vwapValue)
vwapCrossDown = ta.crossunder(close, vwapValue)

// Enhanced VWAP Proximity Detection
distanceFromVWAP = math.abs(close - vwapValue) / vwapValue * 100
nearVWAP = distanceFromVWAP <= vwapProximity

// Price action confirming momentum
priceBouncingUp = close > close[1] and close[1] > close[2]
priceBouncingDown = close < close[1] and close[1] < close[2]
strongMomentumUp = close > close[1] and close > open
strongMomentumDown = close < close[1] and close < open

// PULLBACK SETUPS
nearLowerBand = close <= vwapLower1 and close >= vwapLower2
nearUpperBand = close >= vwapUpper1 and close <= vwapUpper2

pullbackLongSetup = (
    (nearVWAP or nearLowerBand) and
    close <= vwapValue and
    (priceBouncingUp or strongMomentumUp)
)

pullbackShortSetup = (
    (nearVWAP or nearUpperBand) and
    close >= vwapValue and
    (priceBouncingDown or strongMomentumDown)
)

// BREAKOUT SETUPS
breakoutLongSetup = (
    vwapCrossUp or
    (close > vwapValue and
     close[1] <= vwapValue and
     strongMomentumUp)
)

breakoutShortSetup = (
    vwapCrossDown or
    (close < vwapValue and
     close[1] >= vwapValue and
     strongMomentumDown)
)

// Combine based on Entry Mode
var bool isBreakoutEntry = false
var bool isPullbackEntry = false

longVWAPCondition = false
shortVWAPCondition = false

if entryMode == "Pullback Only"
    longVWAPCondition := pullbackLongSetup
    shortVWAPCondition := pullbackShortSetup
    isPullbackEntry := true
    isBreakoutEntry := false
else if entryMode == "Breakout Only"
    longVWAPCondition := breakoutLongSetup
    shortVWAPCondition := breakoutShortSetup
    isBreakoutEntry := true
    isPullbackEntry := false
else  // "Both"
    longVWAPCondition := pullbackLongSetup or breakoutLongSetup
    shortVWAPCondition := pullbackShortSetup or breakoutShortSetup
    isPullbackEntry := pullbackLongSetup or pullbackShortSetup
    isBreakoutEntry := breakoutLongSetup or breakoutShortSetup

// Build entry conditions
longCondition = longVWAPCondition
shortCondition = shortVWAPCondition

// MACD Histogram Filter
if macdHistogramExpansion
    macdDivergenceOpening = math.abs(macdLine - signalLine) > math.abs(macdLine[1] - signalLine[1])
    longCondition := longCondition and histogram > 0 and ((histogramExpanding or (histogramJumpDetection and histogramJump)) or macdDivergenceOpening)
    shortCondition := shortCondition and histogram < 0 and ((histogramContractingDown or (histogramJumpDetection and histogramJumpBearish)) or macdDivergenceOpening)
else
    longCondition := longCondition and histogram > 0
    shortCondition := shortCondition and histogram < 0

// Volume Filter
if volumeConfirmation
    longCondition := longCondition and volumeSurge
    shortCondition := shortCondition and volumeSurge

// Trend Filter
if trendFilter
    longCondition := longCondition and close > ema50
    shortCondition := shortCondition and close < ema50

// FVG Filter
if fvgFilter
    hasBullishFVGSupport = false
    hasBearishFVGResistance = false
    
    if array.size(bullishFVGboxes) > 0
        for i = 0 to array.size(bullishFVGboxes) - 1
            fvgTop = box.get_top(array.get(bullishFVGboxes, i))
            if fvgTop < close
                hasBullishFVGSupport := true
                break
    
    if array.size(bearishFVGboxes) > 0
        for i = 0 to array.size(bearishFVGboxes) - 1
            fvgBottom = box.get_bottom(array.get(bearishFVGboxes, i))
            if fvgBottom > close
                hasBearishFVGResistance := true
                break
    
    longCondition := longCondition and hasBullishFVGSupport
    shortCondition := shortCondition and hasBearishFVGResistance

// Additional MACD confirmation
longCondition := longCondition and macdLine > signalLine
shortCondition := shortCondition and macdLine < signalLine

// Final signals
longSignal = longCondition and showLongs and inDateRange
shortSignal = shortCondition and showShorts and inDateRange

// Determine entry type for current signal
currentEntryType = ""
if longSignal
    if pullbackLongSetup
        currentEntryType := "Pullback"
    else if breakoutLongSetup
        currentEntryType := "Breakout"
else if shortSignal
    if pullbackShortSetup
        currentEntryType := "Pullback"
    else if breakoutShortSetup
        currentEntryType := "Breakout"

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STOP LOSS AND TAKE PROFIT CALCULATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var float longEntryPrice = na
var float longStopLoss = na
var float longTP1 = na
var float longTP2 = na

var float shortEntryPrice = na
var float shortStopLoss = na
var float shortTP1 = na
var float shortTP2 = na

// Calculate swing high/low for swing-based stops
swingLow = ta.lowest(low, 10)
swingHigh = ta.highest(high, 10)

// Long Entry
if longSignal
    longEntryPrice := close
    
    if stopLossMethod == "Percentage"
        longStopLoss := longEntryPrice * (1 - stopLossPct / 100)
    else if stopLossMethod == "Swing"
        longStopLoss := swingLow
    else if stopLossMethod == "ATR"
        longStopLoss := longEntryPrice - (atr * atrMultiplier)
    else if stopLossMethod == "VWAP"
        longStopLoss := vwapLower1
    
    riskAmount = longEntryPrice - longStopLoss
    longTP1 := longEntryPrice + (riskAmount * rrRatio * 0.5)
    longTP2 := longEntryPrice + (riskAmount * rrRatio)

// Short Entry
if shortSignal
    shortEntryPrice := close
    
    if stopLossMethod == "Percentage"
        shortStopLoss := shortEntryPrice * (1 + stopLossPct / 100)
    else if stopLossMethod == "Swing"
        shortStopLoss := swingHigh
    else if stopLossMethod == "ATR"
        shortStopLoss := shortEntryPrice + (atr * atrMultiplier)
    else if stopLossMethod == "VWAP"
        shortStopLoss := vwapUpper1
    
    riskAmount = shortStopLoss - shortEntryPrice
    shortTP1 := shortEntryPrice - (riskAmount * rrRatio * 0.5)
    shortTP2 := shortEntryPrice - (riskAmount * rrRatio)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STRATEGY EXECUTION (BACKTESTING)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if enableBacktest
    // Long Entry
    if longSignal and strategy.position_size == 0
        strategy.entry("Long", strategy.long)
        
    // Long Exits
    if strategy.position_size > 0
        if useTP1Exit
            strategy.exit("TP1", "Long", limit=longTP1, stop=longStopLoss, qty_percent=50)
        if useTP2Exit
            strategy.exit("TP2", "Long", limit=longTP2, stop=longStopLoss)
        else
            strategy.exit("Exit", "Long", stop=longStopLoss)
    
    // Short Entry
    if shortSignal and strategy.position_size == 0
        strategy.entry("Short", strategy.short)
        
    // Short Exits
    if strategy.position_size < 0
        if useTP1Exit
            strategy.exit("TP1", "Short", limit=shortTP1, stop=shortStopLoss, qty_percent=50)
        if useTP2Exit
            strategy.exit("TP2", "Short", limit=shortTP2, stop=shortStopLoss)
        else
            strategy.exit("Exit", "Short", stop=shortStopLoss)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PERFORMANCE STATISTICS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var int totalTrades = 0
var int winningTrades = 0
var int losingTrades = 0
var float totalProfit = 0.0
var float totalLoss = 0.0
var int pullbackTrades = 0
var int breakoutTrades = 0

// Track trade results
if strategy.closedtrades > totalTrades
    totalTrades := strategy.closedtrades
    lastTradeProfit = strategy.closedtrades.profit(strategy.closedtrades - 1)
    
    if lastTradeProfit > 0
        winningTrades += 1
        totalProfit += lastTradeProfit
    else if lastTradeProfit < 0
        losingTrades += 1
        totalLoss += math.abs(lastTradeProfit)

// Calculate statistics
winRate = totalTrades > 0 ? (winningTrades / totalTrades) * 100 : 0
avgWin = winningTrades > 0 ? totalProfit / winningTrades : 0
avgLoss = losingTrades > 0 ? totalLoss / losingTrades : 0
profitFactor = totalLoss > 0 ? totalProfit / totalLoss : 0

// Display stats table
if showStats and barstate.islast
    var table statsTable = table.new(position.top_right, 2, 9, 
                                      bgcolor=color.new(color.black, 10), 
                                      border_width=2, 
                                      border_color=color.new(color.blue, 0))
    
    // Headers
    table.cell(statsTable, 0, 0, "SwingFlow v0.2.2 Stats", 
               text_color=color.white, text_size=size.normal, bgcolor=color.new(color.blue, 30))
    table.cell(statsTable, 1, 0, "", bgcolor=color.new(color.blue, 30))
    
    // Entry Mode
    table.cell(statsTable, 0, 1, "Entry Mode", text_color=color.white, text_size=size.small)
    table.cell(statsTable, 1, 1, entryMode, text_color=color.yellow, text_size=size.small)
    
    // Stats rows
    table.cell(statsTable, 0, 2, "Total Trades", text_color=color.white, text_size=size.small)
    table.cell(statsTable, 1, 2, str.tostring(totalTrades), text_color=color.yellow, text_size=size.small)
    
    table.cell(statsTable, 0, 3, "Win Rate", text_color=color.white, text_size=size.small)
    table.cell(statsTable, 1, 3, str.tostring(winRate, "#.##") + "%", 
               text_color=winRate >= 50 ? color.lime : color.red, text_size=size.small)
    
    table.cell(statsTable, 0, 4, "Winning Trades", text_color=color.white, text_size=size.small)
    table.cell(statsTable, 1, 4, str.tostring(winningTrades), text_color=color.lime, text_size=size.small)
    
    table.cell(statsTable, 0, 5, "Losing Trades", text_color=color.white, text_size=size.small)
    table.cell(statsTable, 1, 5, str.tostring(losingTrades), text_color=color.red, text_size=size.small)
    
    table.cell(statsTable, 0, 6, "Avg Win", text_color=color.white, text_size=size.small)
    table.cell(statsTable, 1, 6, "$" + str.tostring(avgWin, "#.##"), text_color=color.lime, text_size=size.small)
    
    table.cell(statsTable, 0, 7, "Avg Loss", text_color=color.white, text_size=size.small)
    table.cell(statsTable, 1, 7, "$" + str.tostring(avgLoss, "#.##"), text_color=color.red, text_size=size.small)
    
    table.cell(statsTable, 0, 8, "Profit Factor", text_color=color.white, text_size=size.small)
    table.cell(statsTable, 1, 8, str.tostring(profitFactor, "#.##"), 
               text_color=profitFactor >= 2 ? color.lime : profitFactor >= 1 ? color.yellow : color.red, 
               text_size=size.small)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VISUAL PLOTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// VWAP and Bands
plot(showVWAPBands ? vwapValue : na, "VWAP", color=color.new(color.blue, 0), linewidth=2)
plot(showVWAPBands ? vwapUpper1 : na, "VWAP +1Ïƒ", color=color.new(color.blue, 70), linewidth=1)
plot(showVWAPBands ? vwapLower1 : na, "VWAP -1Ïƒ", color=color.new(color.blue, 70), linewidth=1)
plot(showVWAPBands ? vwapUpper2 : na, "VWAP +2Ïƒ", color=color.new(color.blue, 85), linewidth=1, style=plot.style_circles)
plot(showVWAPBands ? vwapLower2 : na, "VWAP -2Ïƒ", color=color.new(color.blue, 85), linewidth=1, style=plot.style_circles)

// 50 EMA
plot(show50EMA ? ema50 : na, "50 EMA", color=color.new(color.orange, 0), linewidth=2)

// Entry Arrows - Different colors for pullback vs breakout
arrowColorLong = currentEntryType == "Pullback" ? color.new(color.green, 0) : color.new(color.lime, 0)
arrowColorShort = currentEntryType == "Pullback" ? color.new(color.red, 0) : color.new(color.fuchsia, 0)

plotshape(showEntryArrows and longSignal, "Long Entry", shape.triangleup, location.belowbar, 
          color=arrowColorLong, size=size.small)
plotshape(showEntryArrows and shortSignal, "Short Entry", shape.triangledown, location.abovebar, 
          color=arrowColorShort, size=size.small)

// Entry Labels with R:R info and Entry Type
if showRRLabel and longSignal
    riskPct = (longEntryPrice - longStopLoss) / longEntryPrice * 100
    tp1Pct = (longTP1 - longEntryPrice) / longEntryPrice * 100
    tp2Pct = (longTP2 - longEntryPrice) / longEntryPrice * 100
    entryTypeLabel = showEntryType ? "\nğŸ“ " + currentEntryType : ""
    labelText = "ğŸ“ˆ LONG $" + str.tostring(longEntryPrice, "#.##") + entryTypeLabel + "\n" +
                 "ğŸ›¡ï¸ SL: $" + str.tostring(longStopLoss, "#.##") + " (-" + str.tostring(riskPct, "#.#") + "%)\n" +
                 "ğŸ¯ TP1: $" + str.tostring(longTP1, "#.##") + " (+" + str.tostring(tp1Pct, "#.#") + "%)\n" +
                 "ğŸ¯ TP2: $" + str.tostring(longTP2, "#.##") + " (+" + str.tostring(tp2Pct, "#.#") + "%)"
    label.new(bar_index, low, labelText, 
              style=label.style_label_up, 
              color=arrowColorLong, 
              textcolor=color.white, 
              size=size.small)

if showRRLabel and shortSignal
    riskPct = (shortStopLoss - shortEntryPrice) / shortEntryPrice * 100
    tp1Pct = (shortEntryPrice - shortTP1) / shortEntryPrice * 100
    tp2Pct = (shortEntryPrice - shortTP2) / shortEntryPrice * 100
    entryTypeLabel = showEntryType ? "\nğŸ“ " + currentEntryType : ""
    labelText = "ğŸ“‰ SHORT $" + str.tostring(shortEntryPrice, "#.##") + entryTypeLabel + "\n" +
                 "ğŸ›¡ï¸ SL: $" + str.tostring(shortStopLoss, "#.##") + " (+" + str.tostring(riskPct, "#.#") + "%)\n" +
                 "ğŸ¯ TP1: $" + str.tostring(shortTP1, "#.##") + " (-" + str.tostring(tp1Pct, "#.#") + "%)\n" +
                 "ğŸ¯ TP2: $" + str.tostring(shortTP2, "#.##") + " (-" + str.tostring(tp2Pct, "#.#") + "%)"
    label.new(bar_index, high, labelText, 
              style=label.style_label_down, 
              color=arrowColorShort, 
              textcolor=color.white, 
              size=size.small)

// Stop Loss Lines
var line longSLLine = na
var line shortSLLine = na

if showStopLoss and longSignal
    if not na(longSLLine)
        line.delete(longSLLine)
    longSLLine := line.new(bar_index, longStopLoss, bar_index + 20, longStopLoss, 
                            color=color.new(color.blue, 0), width=2, style=line.style_dashed)

if showStopLoss and shortSignal
    if not na(shortSLLine)
        line.delete(shortSLLine)
    shortSLLine := line.new(bar_index, shortStopLoss, bar_index + 20, shortStopLoss, 
                             color=color.new(color.blue, 0), width=2, style=line.style_dashed)

// Take Profit Lines
var line longTP1Line = na
var line longTP2Line = na
var line shortTP1Line = na
var line shortTP2Line = na

if showTakeProfit and longSignal
    if not na(longTP1Line)
        line.delete(longTP1Line)
    if not na(longTP2Line)
        line.delete(longTP2Line)
    longTP1Line := line.new(bar_index, longTP1, bar_index + 20, longTP1, 
                             color=color.new(color.yellow, 0), width=2)
    longTP2Line := line.new(bar_index, longTP2, bar_index + 20, longTP2, 
                             color=color.new(color.orange, 0), width=2)

if showTakeProfit and shortSignal
    if not na(shortTP1Line)
        line.delete(shortTP1Line)
    if not na(shortTP2Line)
        line.delete(shortTP2Line)
    shortTP1Line := line.new(bar_index, shortTP1, bar_index + 20, shortTP1, 
                              color=color.new(color.yellow, 0), width=2)
    shortTP2Line := line.new(bar_index, shortTP2, bar_index + 20, shortTP2, 
                              color=color.new(color.orange, 0), width=2)

// Histogram Jump Visual Indicator
plotshape(histogramJumpDetection and histogramJump, "Histogram Jump (Bull)", 
          shape.diamond, location.belowbar, color=color.new(color.lime, 0), size=size.tiny)
plotshape(histogramJumpDetection and histogramJumpBearish, "Histogram Jump (Bear)", 
          shape.diamond, location.abovebar, color=color.new(color.fuchsia, 0), size=size.tiny)

//@version=5
// ============================================================================
// SWINGFLOW v0.1.2
// Advanced Pullback Trading Strategy with Improved Swing Level Detection
// 
// Support the developer: https://buymeacoffee.com/savowood
// ============================================================================

strategy("SwingFlow v0.1.2", 
         shorttitle="SwingFlow v0.1.2", 
         overlay=true, 
         initial_capital=100000,
         default_qty_type=strategy.percent_of_equity,
         default_qty_value=100,
         commission_type=strategy.commission.percent,
         commission_value=0.1,
         slippage=2,
         max_lines_count=500,
         max_labels_count=500,
         max_boxes_count=500)

// ============================================================================
// INPUT PARAMETERS
// ============================================================================

// Trading Style Selection
tradingStyle = input.string("Swing", "Trading Style", options=["Intraday", "Swing", "Medium-Term", "Long-Term"], group="Trading Style")

// Swing Level Detection Settings (New in v0.1.2)
showSwingLevels = input.bool(true, "Show Swing Levels", group="Swing Levels")
swingLength = input.int(25, "Swing Detection Length", minval=5, maxval=50, 
     tooltip="Higher values = fewer, more significant swings", group="Swing Levels")
minSwingStrength = input.float(0.3, "Minimum Swing Strength", minval=0.1, maxval=1.0, step=0.1,
     tooltip="Filters out weak swings (0.3 = moderate strength required)", group="Swing Levels")
touchSensitivity = input.float(0.5, "Touch Sensitivity", minval=0.2, maxval=2.0, step=0.1,
     tooltip="Higher = more lenient touch detection (0.5 = balanced)", group="Swing Levels")
minTouches = input.int(2, "Minimum Touches to Display", minval=1, maxval=5,
     tooltip="Only show levels with this many touches", group="Swing Levels")
maxSwingLevels = input.int(5, "Maximum Swing Levels", minval=3, maxval=10,
     tooltip="Limit number of displayed levels for clarity", group="Swing Levels")
showOldSwings = input.bool(false, "Show Inactive Swings", 
     tooltip="Keep or remove swings after breakout", group="Swing Levels")
barsToKeepSwing = input.int(50, "Bars Before Removing Swing", minval=20, maxval=200, group="Swing Levels")
lineWidth = input.int(2, "Line Width", minval=1, maxval=4, group="Swing Levels")
labelSize = input.string("small", "Label Size", options=["tiny", "small", "normal", "large"], group="Swing Levels")

// EMA Settings (9/20/180 Setup)
ema9Length = input.int(9, "Fast EMA (9)", minval=1, group="EMAs")
ema20Length = input.int(20, "Medium EMA (20)", minval=1, group="EMAs")
ema180Length = input.int(180, "Slow EMA (180)", minval=1, group="EMAs")
useEmaFilter = input.bool(true, "Require Price Above 9/20/180 EMA Stack", group="EMAs")

// VWAP Settings
useVwap = input.bool(true, "Use VWAP", group="VWAP")
vwapPullbackType = input.string("Touch", "VWAP Pullback Type", options=["Touch", "Cross Below Then Above", "Within Range"], group="VWAP")
vwapRangePercent = input.float(0.3, "VWAP Range % (for Within Range)", minval=0.1, maxval=5, step=0.1, group="VWAP")
showVwapStdDev = input.bool(true, "Show VWAP Standard Deviation Bands", group="VWAP")
vwapStdDev1 = input.float(1.0, "VWAP 1st StdDev Multiplier", minval=0.1, maxval=5, step=0.1, group="VWAP")
vwapStdDev2 = input.float(2.0, "VWAP 2nd StdDev Multiplier", minval=0.1, maxval=5, step=0.1, group="VWAP")

// Fair Value Gap (FVG) Settings
showFVG = input.bool(true, "Show Fair Value Gaps", group="Fair Value Gaps")
fvgExtend = input.int(10, "FVG Extension Bars", minval=1, maxval=100, group="Fair Value Gaps")

// MACD Settings
macdFast = input.int(12, "MACD Fast Length", minval=1, group="MACD")
macdSlow = input.int(26, "MACD Slow Length", minval=1, group="MACD")
macdSignal = input.int(9, "MACD Signal Length", minval=1, group="MACD")
useMacdConfirmation = input.bool(true, "Require MACD Bullish", group="MACD")
requireMacdCrossover = input.bool(true, "Require Recent MACD Crossover", group="MACD")

// Additional Indicators (Optional)
useRsi = input.bool(true, "Use RSI Filter", group="Additional Filters")
rsiLength = input.int(14, "RSI Length", minval=1, group="Additional Filters")
rsiOversold = input.int(40, "RSI Oversold Level", minval=1, maxval=50, group="Additional Filters")
rsiOverbought = input.int(65, "RSI Overbought Level", minval=50, maxval=99, group="Additional Filters")

useStochastic = input.bool(false, "Use Stochastic Filter", group="Additional Filters")
stochLength = input.int(14, "Stochastic %K Length", minval=1, group="Additional Filters")
stochSmooth = input.int(3, "Stochastic %K Smoothing", minval=1, group="Additional Filters")
stochOversold = input.int(20, "Stochastic Oversold", minval=1, maxval=50, group="Additional Filters")

useBollinger = input.bool(false, "Use Bollinger Bands Filter", group="Additional Filters")
bbLength = input.int(20, "Bollinger Length", minval=1, group="Additional Filters")
bbStdDev = input.float(2.0, "Bollinger Std Dev", minval=0.5, maxval=5, step=0.1, group="Additional Filters")

// Volume Filter
useVolumeFilter = input.bool(true, "Require Above Average Volume", group="Volume")
volumeMultiplier = input.float(1.5, "Volume Multiplier", minval=0.5, maxval=5, step=0.1, group="Volume")
volumeAvgLength = input.int(20, "Volume Average Length", minval=1, group="Volume")

// Risk Management
riskRewardRatio = input.float(3.0, "Risk:Reward Ratio", minval=0.5, maxval=10, step=0.5, group="Risk Management")
stopLossType = input.string("ATR-Based", "Stop Loss Type", options=["ATR-Based", "Percentage", "Recent Low"], group="Risk Management")
stopLossPercent = input.float(2.0, "Stop Loss % (if Percentage)", minval=0.1, maxval=10, step=0.1, group="Risk Management")
atrLength = input.int(14, "ATR Length", minval=1, group="Risk Management")
atrMultiplier = input.float(2.0, "ATR Multiplier for Stop", minval=0.5, maxval=5, step=0.25, group="Risk Management")
useTrailingStop = input.bool(true, "Use Trailing Stop", group="Risk Management")
trailStopATRMult = input.float(2.5, "Trailing Stop ATR Multiplier", minval=0.5, maxval=5, step=0.25, group="Risk Management")

// Position Sizing
positionSizePercent = input.float(100, "Position Size (% of Equity)", minval=1, maxval=100, step=1, group="Position Sizing")
maxPositions = input.int(1, "Max Concurrent Positions", minval=1, maxval=10, group="Position Sizing")

// ============================================================================
// INDICATOR CALCULATIONS
// ============================================================================

// EMAs (9/20/180 Setup)
ema9 = ta.ema(close, ema9Length)
ema20 = ta.ema(close, ema20Length)
ema180 = ta.ema(close, ema180Length)

// VWAP
vwapValue = ta.vwap(close)

// VWAP Standard Deviation Bands
vwapStdDevValue = ta.stdev(close - vwapValue, 20)
vwapUpper1 = vwapValue + (vwapStdDevValue * vwapStdDev1)
vwapLower1 = vwapValue - (vwapStdDevValue * vwapStdDev1)
vwapUpper2 = vwapValue + (vwapStdDevValue * vwapStdDev2)
vwapLower2 = vwapValue - (vwapStdDevValue * vwapStdDev2)

// MACD
[macdLine, signalLine, macdHist] = ta.macd(close, macdFast, macdSlow, macdSignal)

// ATR for volatility-based stops and swing detection
atr = ta.atr(atrLength)

// RSI
rsi = ta.rsi(close, rsiLength)

// Stochastic
stochK = ta.stoch(close, high, low, stochLength)
stochD = ta.sma(stochK, stochSmooth)

// Bollinger Bands
bbBasis = ta.sma(close, bbLength)
bbDev = bbStdDev * ta.stdev(close, bbLength)
bbUpper = bbBasis + bbDev
bbLower = bbBasis - bbDev

// Volume
avgVolume = ta.sma(volume, volumeAvgLength)

// ============================================================================
// IMPROVED SWING LEVEL DETECTION (v0.1.2)
// ============================================================================

// Calculate swing highs and lows
swingHigh = ta.pivothigh(high, swingLength, swingLength)
swingLow = ta.pivotlow(low, swingLength, swingLength)

// Touch threshold for swing levels
touchThreshold = atr * touchSensitivity

// Swing level tracking arrays
var array<float> swingLevels = array.new<float>()
var array<int> swingBars = array.new<int>()
var array<int> touchCounts = array.new<int>()
var array<bool> isSupport = array.new<bool>()
var array<int> lastTouchBar = array.new<int>()

// Function to calculate swing strength
calcSwingStrength(priceLevel, lookback) =>
    strength = 0.0
    touchCount = 0
    for i = 1 to lookback
        if math.abs(high[i] - priceLevel) <= touchThreshold or math.abs(low[i] - priceLevel) <= touchThreshold
            touchCount += 1
    strength := touchCount / lookback
    strength

// Add new swing high
if showSwingLevels and not na(swingHigh)
    swingStrength = calcSwingStrength(swingHigh, swingLength * 2)
    if swingStrength >= minSwingStrength
        array.push(swingLevels, swingHigh)
        array.push(swingBars, bar_index - swingLength)
        array.push(touchCounts, 1)
        array.push(isSupport, false)
        array.push(lastTouchBar, bar_index - swingLength)

// Add new swing low
if showSwingLevels and not na(swingLow)
    swingStrength = calcSwingStrength(swingLow, swingLength * 2)
    if swingStrength >= minSwingStrength
        array.push(swingLevels, swingLow)
        array.push(swingBars, bar_index - swingLength)
        array.push(touchCounts, 1)
        array.push(isSupport, true)
        array.push(lastTouchBar, bar_index - swingLength)

// Touch detection and level management
if showSwingLevels and array.size(swingLevels) > 0
    for i = array.size(swingLevels) - 1 to 0
        // Safety check - ensure all arrays are same size
        if i < array.size(swingLevels) and 
           i < array.size(swingBars) and 
           i < array.size(touchCounts) and 
           i < array.size(isSupport) and 
           i < array.size(lastTouchBar)
            
            level = array.get(swingLevels, i)
            barAge = bar_index - array.get(swingBars, i)
            lastTouch = bar_index - array.get(lastTouchBar, i)
            
            // Check for new touches
            isTouching = math.abs(high - level) <= touchThreshold or math.abs(low - level) <= touchThreshold
            if isTouching
                array.set(touchCounts, i, array.get(touchCounts, i) + 1)
                array.set(lastTouchBar, i, bar_index)
            
            // Remove old or broken levels
            shouldRemove = false
            
            // Remove if too old without recent touches
            if not showOldSwings and lastTouch > barsToKeepSwing
                shouldRemove := true
            
            // Remove if price clearly broke through
            supportBroken = array.get(isSupport, i) and close < level - (touchThreshold * 2)
            resistanceBroken = not array.get(isSupport, i) and close > level + (touchThreshold * 2)
            if not showOldSwings and (supportBroken or resistanceBroken)
                shouldRemove := true
            
            if shouldRemove
                array.remove(swingLevels, i)
                array.remove(swingBars, i)
                array.remove(touchCounts, i)
                array.remove(isSupport, i)
                array.remove(lastTouchBar, i)

// Sort and limit swing levels
if showSwingLevels and array.size(swingLevels) > maxSwingLevels
    while array.size(swingLevels) > maxSwingLevels
        // Safety check
        if array.size(touchCounts) > 0
            // Find index with lowest touch count
            minTouchIdx = 0
            minTouchCount = array.get(touchCounts, 0)
            for i = 1 to array.size(touchCounts) - 1
                if array.get(touchCounts, i) < minTouchCount
                    minTouchCount := array.get(touchCounts, i)
                    minTouchIdx := i
            
            // Remove the weakest level
            array.remove(swingLevels, minTouchIdx)
            array.remove(swingBars, minTouchIdx)
            array.remove(touchCounts, minTouchIdx)
            array.remove(isSupport, minTouchIdx)
            array.remove(lastTouchBar, minTouchIdx)
        else
            break

// Visualize swing levels
var array<line> swingLines = array.new<line>()
var array<label> swingLabels = array.new<label>()

if showSwingLevels and barstate.islast
    // Clear previous drawings
    if array.size(swingLines) > 0
        for i = 0 to array.size(swingLines) - 1
            line.delete(array.get(swingLines, i))
    if array.size(swingLabels) > 0
        for i = 0 to array.size(swingLabels) - 1
            label.delete(array.get(swingLabels, i))
    array.clear(swingLines)
    array.clear(swingLabels)
    
    // Draw current swing levels
    if array.size(swingLevels) > 0
        for i = 0 to array.size(swingLevels) - 1
            // Safety check before accessing arrays
            if i < array.size(swingLevels) and 
               i < array.size(swingBars) and 
               i < array.size(touchCounts) and 
               i < array.size(isSupport)
                
                level = array.get(swingLevels, i)
                startBar = array.get(swingBars, i)
                touches = array.get(touchCounts, i)
                isSup = array.get(isSupport, i)
                
                // Only display if meets minimum touch requirement
                if touches >= minTouches
                    // Determine color and style
                    lineColor = isSup ? color.green : color.red
                    lineStyle = touches >= 3 ? line.style_solid : line.style_dashed
                    
                    // Determine line strength based on touches
                    displayWidth = touches >= 4 ? lineWidth + 1 : lineWidth
                    
                    // Draw line
                    l = line.new(startBar, level, bar_index + 10, level, 
                         color=lineColor, width=displayWidth, style=lineStyle)
                    array.push(swingLines, l)
                    
                    // Create label text
                    labelText = str.tostring(touches) + " touch" + (touches > 1 ? "es" : "")
                    labelColor = isSup ? color.new(color.green, 20) : color.new(color.red, 20)
                    labelStyle = isSup ? label.style_label_up : label.style_label_down
                    
                    // Size based on input
                    lblSize = labelSize == "tiny" ? size.tiny : 
                             labelSize == "small" ? size.small :
                             labelSize == "normal" ? size.normal : size.large
                    
                    // Draw label
                    lbl = label.new(bar_index, level, labelText, 
                         color=labelColor, textcolor=lineColor, 
                         style=labelStyle, size=lblSize)
                    array.push(swingLabels, lbl)

// Check if price is near a swing level (for integration with strategy)
nearSwingSupport = false
nearSwingResistance = false

if showSwingLevels and array.size(swingLevels) > 0
    for i = 0 to array.size(swingLevels) - 1
        if i < array.size(swingLevels) and i < array.size(isSupport)
            level = array.get(swingLevels, i)
            isSup = array.get(isSupport, i)
            
            if math.abs(close - level) <= touchThreshold * 1.5
                if isSup
                    nearSwingSupport := true
                else
                    nearSwingResistance := true

// ============================================================================
// FAIR VALUE GAP (FVG) DETECTION
// ============================================================================

// Bullish FVG: Gap between current low and 2 bars ago high
bullishFVG = low > high[2] and close > open

// Bearish FVG: Gap between current high and 2 bars ago low
bearishFVG = high < low[2] and close < open

// Store FVG levels
var box[] bullishFVGBoxes = array.new_box()
var box[] bearishFVGBoxes = array.new_box()

// Create boxes for new FVGs
if showFVG and bullishFVG
    fvgBox = box.new(bar_index - 2, high[2], bar_index + fvgExtend, low, 
                     border_color=color.new(color.green, 80), 
                     bgcolor=color.new(color.green, 90),
                     border_width=1,
                     extend=extend.none)
    array.push(bullishFVGBoxes, fvgBox)

if showFVG and bearishFVG
    fvgBox = box.new(bar_index - 2, low[2], bar_index + fvgExtend, high,
                     border_color=color.new(color.red, 80),
                     bgcolor=color.new(color.red, 90),
                     border_width=1,
                     extend=extend.none)
    array.push(bearishFVGBoxes, fvgBox)

// ============================================================================
// TRADING CONDITIONS
// ============================================================================

// EMA Stack Condition
emaStackBullish = close > ema9 and ema9 > ema20 and ema20 > ema180
emaFilter = useEmaFilter ? emaStackBullish : true

// VWAP Conditions
vwapTouch = math.abs(close - vwapValue) <= (close * vwapRangePercent / 100)
vwapCrossBelow = ta.crossunder(close[1], vwapValue[1])
vwapCrossAbove = ta.crossover(close, vwapValue)
vwapWithinRange = close > vwapValue * (1 - vwapRangePercent/100) and close < vwapValue * (1 + vwapRangePercent/100)

vwapCondition = if not useVwap
    true
else if vwapPullbackType == "Touch"
    vwapTouch
else if vwapPullbackType == "Cross Below Then Above"
    vwapCrossAbove and vwapCrossBelow[1]
else  // Within Range
    vwapWithinRange

// MACD Conditions
macdBullish = macdLine > signalLine
macdCrossover = ta.crossover(macdLine, signalLine)
recentMacdCrossover = ta.barssince(macdCrossover) <= 5

macdCondition = if not useMacdConfirmation
    true
else if requireMacdCrossover
    macdBullish and recentMacdCrossover
else
    macdBullish

// RSI Condition
rsiCondition = useRsi ? (rsi > rsiOversold and rsi < rsiOverbought) : true

// Stochastic Condition
stochCondition = useStochastic ? (stochK > stochOversold) : true

// Bollinger Bands Condition
bbCondition = useBollinger ? (close > bbLower and close < bbUpper) : true

// Volume Condition
volumeCondition = useVolumeFilter ? (volume > avgVolume * volumeMultiplier) : true

// Price Action - Bullish Patterns
isBullishEngulfing = close > open and close[1] < open[1] and close > open[1] and open < close[1]
isBullishHammer = (close > open) and ((high - close) < (close - open) * 0.3) and ((open - low) > (close - open) * 2)
isBullishMorningstar = close[2] < open[2] and math.abs(close[1] - open[1]) < (high[1] - low[1]) * 0.3 and close > open and close > (open[2] + close[2]) / 2

priceActionBullish = isBullishEngulfing or isBullishHammer or isBullishMorningstar

// Lookback for pullback detection (adjusted by trading style)
lookbackBars = tradingStyle == "Intraday" ? 10 : tradingStyle == "Swing" ? 20 : tradingStyle == "Medium-Term" ? 30 : 50

// Pullback Detection
recentHigh = ta.highest(high, lookbackBars)
isPullback = high < recentHigh and close > open

// Enhanced with swing level awareness
pullbackToSwingLevel = showSwingLevels ? (nearSwingSupport and not nearSwingResistance) : true

// Long Entry Signal
longCondition = isPullback and emaFilter and vwapCondition and macdCondition and rsiCondition and stochCondition and bbCondition and volumeCondition and priceActionBullish and pullbackToSwingLevel and strategy.position_size == 0

// ============================================================================
// POSITION MANAGEMENT
// ============================================================================

var float entryPrice = na
var float stopLoss = na
var float takeProfit = na
var float trailStop = na

if longCondition
    entryPrice := close
    
    // Calculate Stop Loss
    if stopLossType == "ATR-Based"
        stopLoss := entryPrice - (atr * atrMultiplier)
    else if stopLossType == "Percentage"
        stopLoss := entryPrice * (1 - stopLossPercent/100)
    else  // Recent Low
        stopLoss := ta.lowest(low, lookbackBars) * 0.995
    
    // Calculate Take Profit based on Risk:Reward
    riskAmount = entryPrice - stopLoss
    takeProfit := entryPrice + (riskAmount * riskRewardRatio)
    
    // Initialize trailing stop
    trailStop := entryPrice - (atr * trailStopATRMult)
    
    // Enter Long Position
    strategy.entry("Long", strategy.long, qty=positionSizePercent/100)

// Update Trailing Stop
if strategy.position_size > 0 and useTrailingStop
    newTrailStop = close - (atr * trailStopATRMult)
    trailStop := math.max(trailStop, newTrailStop)

// Exit Conditions
if strategy.position_size > 0
    if useTrailingStop
        strategy.exit("Exit Long", "Long", stop=trailStop, limit=takeProfit)
    else
        strategy.exit("Exit Long", "Long", stop=stopLoss, limit=takeProfit)

// ============================================================================
// PLOTTING
// ============================================================================

// Plot EMAs
plot(ema9, "EMA 9", color=color.new(color.blue, 0), linewidth=2)
plot(ema20, "EMA 20", color=color.new(color.orange, 0), linewidth=2)
plot(ema180, "EMA 180", color=color.new(color.red, 0), linewidth=2)

// Plot VWAP
plot(useVwap ? vwapValue : na, "VWAP", color=color.new(color.purple, 0), linewidth=2, style=plot.style_circles)

// Plot VWAP Standard Deviation Bands
plot(showVwapStdDev and useVwap ? vwapUpper1 : na, "VWAP +1 StdDev", 
     color=color.new(color.purple, 60), linewidth=1, style=plot.style_line)
plot(showVwapStdDev and useVwap ? vwapLower1 : na, "VWAP -1 StdDev", 
     color=color.new(color.purple, 60), linewidth=1, style=plot.style_line)
plot(showVwapStdDev and useVwap ? vwapUpper2 : na, "VWAP +2 StdDev", 
     color=color.new(color.purple, 70), linewidth=1, style=plot.style_line)
plot(showVwapStdDev and useVwap ? vwapLower2 : na, "VWAP -2 StdDev", 
     color=color.new(color.purple, 70), linewidth=1, style=plot.style_line)

// Plot Bollinger Bands
plot(useBollinger ? bbUpper : na, "BB Upper", color=color.new(color.gray, 70))
plot(useBollinger ? bbLower : na, "BB Lower", color=color.new(color.gray, 70))
plot(useBollinger ? bbBasis : na, "BB Basis", color=color.new(color.gray, 50))

// Plot Entry/Exit Labels
plotshape(longCondition, "LONG ENTRY", shape.labelup, location.belowbar, 
          color=color.new(color.green, 0), text="LONG\nENTRY", textcolor=color.white, size=size.normal)

// Plot exit labels
exitSignal = strategy.position_size[1] > 0 and strategy.position_size == 0
plotshape(exitSignal and close > strategy.opentrades.entry_price(0)[1], "EXIT PROFIT", shape.labeldown, location.abovebar,
          color=color.new(color.green, 0), text="EXIT\nPROFIT", textcolor=color.white, size=size.normal)
plotshape(exitSignal and close < strategy.opentrades.entry_price(0)[1], "EXIT LOSS", shape.labeldown, location.abovebar,
          color=color.new(color.red, 0), text="EXIT\nLOSS", textcolor=color.white, size=size.normal)

// Plot Stop Loss and Take Profit lines
plot(strategy.position_size > 0 ? (useTrailingStop ? trailStop : stopLoss) : na, 
     "Stop Loss", color=color.new(color.red, 0), linewidth=2, style=plot.style_linebr)
plot(strategy.position_size > 0 ? takeProfit : na, 
     "Take Profit", color=color.new(color.green, 0), linewidth=2, style=plot.style_linebr)

// Add price labels for active positions
if strategy.position_size > 0 and barstate.islast
    var label entryPriceLabel = na
    var label stopLabel = na
    var label targetLabel = na
    
    label.delete(entryPriceLabel)
    label.delete(stopLabel)
    label.delete(targetLabel)
    
    entryPriceLabel := label.new(bar_index, entryPrice, 
                                  text="Entry: " + str.tostring(entryPrice, "#.##"),
                                  style=label.style_label_left, color=color.blue, textcolor=color.white, size=size.normal)
    stopLabel := label.new(bar_index, useTrailingStop ? trailStop : stopLoss,
                           text="Stop: " + str.tostring(useTrailingStop ? trailStop : stopLoss, "#.##"),
                           style=label.style_label_left, color=color.red, textcolor=color.white, size=size.normal)
    targetLabel := label.new(bar_index, takeProfit,
                             text="Target: " + str.tostring(takeProfit, "#.##"),
                             style=label.style_label_left, color=color.green, textcolor=color.white, size=size.normal)

// ============================================================================
// ALERTS
// ============================================================================

alertcondition(longCondition, title="Pullback Entry Signal", 
               message="SwingFlow v0.1.2: LONG Entry Signal Detected!")

alertcondition(nearSwingSupport and showSwingLevels, title="Near Swing Support",
               message="SwingFlow v0.1.2: Price approaching swing support level!")

// ============================================================================
// DASHBOARD
// ============================================================================

var table dashboard = table.new(position.top_right, 2, 9, bgcolor=color.new(color.black, 80), frame_color=color.new(color.blue, 50), frame_width=1)

if barstate.islast
    table.cell(dashboard, 0, 0, "SwingFlow v0.1.2", text_color=color.yellow, bgcolor=color.new(color.blue, 60), text_size=size.small)
    table.cell(dashboard, 1, 0, tradingStyle, text_color=color.white, bgcolor=color.new(color.blue, 90), text_size=size.small)
    
    table.cell(dashboard, 0, 1, "EMA Stack", text_color=color.white, bgcolor=color.new(color.blue, 70))
    table.cell(dashboard, 1, 1, emaStackBullish ? "✓ Bullish" : "✗ Bearish", 
               text_color=emaStackBullish ? color.lime : color.red, bgcolor=color.new(color.blue, 90))
    
    table.cell(dashboard, 0, 2, "VWAP Signal", text_color=color.white, bgcolor=color.new(color.blue, 70))
    table.cell(dashboard, 1, 2, vwapCondition ? "✓ Active" : "✗ Waiting", 
               text_color=vwapCondition ? color.lime : color.orange, bgcolor=color.new(color.blue, 90))
    
    table.cell(dashboard, 0, 3, "MACD", text_color=color.white, bgcolor=color.new(color.blue, 70))
    table.cell(dashboard, 1, 3, macdBullish ? "✓ Bullish" : "✗ Bearish", 
               text_color=macdBullish ? color.lime : color.red, bgcolor=color.new(color.blue, 90))
    
    table.cell(dashboard, 0, 4, "RSI", text_color=color.white, bgcolor=color.new(color.blue, 70))
    table.cell(dashboard, 1, 4, str.tostring(math.round(rsi, 1)), 
               text_color=color.white, bgcolor=color.new(color.blue, 90))
    
    table.cell(dashboard, 0, 5, "Volume", text_color=color.white, bgcolor=color.new(color.blue, 70))
    table.cell(dashboard, 1, 5, volumeCondition ? "✓ Strong" : "✗ Weak", 
               text_color=volumeCondition ? color.lime : color.orange, bgcolor=color.new(color.blue, 90))
    
    table.cell(dashboard, 0, 6, "Swing Levels", text_color=color.white, bgcolor=color.new(color.blue, 70))
    swingStatus = showSwingLevels ? (nearSwingSupport ? "✓ Near Sup" : nearSwingResistance ? "⚠ Near Res" : "Monitoring") : "Off"
    swingColor = nearSwingSupport ? color.lime : nearSwingResistance ? color.orange : color.gray
    table.cell(dashboard, 1, 6, swingStatus, text_color=swingColor, bgcolor=color.new(color.blue, 90))
    
    table.cell(dashboard, 0, 7, "Position", text_color=color.white, bgcolor=color.new(color.blue, 70))
    table.cell(dashboard, 1, 7, strategy.position_size > 0 ? "LONG" : "None", 
               text_color=strategy.position_size > 0 ? color.lime : color.gray, bgcolor=color.new(color.blue, 90))
    
    table.cell(dashboard, 0, 8, "R:R Ratio", text_color=color.white, bgcolor=color.new(color.blue, 70))
    table.cell(dashboard, 1, 8, str.tostring(riskRewardRatio) + ":1", 
               text_color=color.yellow, bgcolor=color.new(color.blue, 90))

